// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package fsmock

import (
	"context"

	"github.com/slok/sloth/internal/pluginengine/sli"
	"github.com/slok/sloth/internal/pluginengine/slo"
	mock "github.com/stretchr/testify/mock"
)

// NewSLIPluginLoader creates a new instance of SLIPluginLoader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSLIPluginLoader(t interface {
	mock.TestingT
	Cleanup(func())
}) *SLIPluginLoader {
	mock := &SLIPluginLoader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SLIPluginLoader is an autogenerated mock type for the SLIPluginLoader type
type SLIPluginLoader struct {
	mock.Mock
}

type SLIPluginLoader_Expecter struct {
	mock *mock.Mock
}

func (_m *SLIPluginLoader) EXPECT() *SLIPluginLoader_Expecter {
	return &SLIPluginLoader_Expecter{mock: &_m.Mock}
}

// LoadRawSLIPlugin provides a mock function for the type SLIPluginLoader
func (_mock *SLIPluginLoader) LoadRawSLIPlugin(ctx context.Context, src string) (*sli.SLIPlugin, error) {
	ret := _mock.Called(ctx, src)

	if len(ret) == 0 {
		panic("no return value specified for LoadRawSLIPlugin")
	}

	var r0 *sli.SLIPlugin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*sli.SLIPlugin, error)); ok {
		return returnFunc(ctx, src)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *sli.SLIPlugin); ok {
		r0 = returnFunc(ctx, src)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sli.SLIPlugin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, src)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SLIPluginLoader_LoadRawSLIPlugin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadRawSLIPlugin'
type SLIPluginLoader_LoadRawSLIPlugin_Call struct {
	*mock.Call
}

// LoadRawSLIPlugin is a helper method to define mock.On call
//   - ctx context.Context
//   - src string
func (_e *SLIPluginLoader_Expecter) LoadRawSLIPlugin(ctx interface{}, src interface{}) *SLIPluginLoader_LoadRawSLIPlugin_Call {
	return &SLIPluginLoader_LoadRawSLIPlugin_Call{Call: _e.mock.On("LoadRawSLIPlugin", ctx, src)}
}

func (_c *SLIPluginLoader_LoadRawSLIPlugin_Call) Run(run func(ctx context.Context, src string)) *SLIPluginLoader_LoadRawSLIPlugin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SLIPluginLoader_LoadRawSLIPlugin_Call) Return(sLIPlugin *sli.SLIPlugin, err error) *SLIPluginLoader_LoadRawSLIPlugin_Call {
	_c.Call.Return(sLIPlugin, err)
	return _c
}

func (_c *SLIPluginLoader_LoadRawSLIPlugin_Call) RunAndReturn(run func(ctx context.Context, src string) (*sli.SLIPlugin, error)) *SLIPluginLoader_LoadRawSLIPlugin_Call {
	_c.Call.Return(run)
	return _c
}

// NewSLOPluginLoader creates a new instance of SLOPluginLoader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSLOPluginLoader(t interface {
	mock.TestingT
	Cleanup(func())
}) *SLOPluginLoader {
	mock := &SLOPluginLoader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// SLOPluginLoader is an autogenerated mock type for the SLOPluginLoader type
type SLOPluginLoader struct {
	mock.Mock
}

type SLOPluginLoader_Expecter struct {
	mock *mock.Mock
}

func (_m *SLOPluginLoader) EXPECT() *SLOPluginLoader_Expecter {
	return &SLOPluginLoader_Expecter{mock: &_m.Mock}
}

// LoadRawPlugin provides a mock function for the type SLOPluginLoader
func (_mock *SLOPluginLoader) LoadRawPlugin(ctx context.Context, src string) (*slo.Plugin, error) {
	ret := _mock.Called(ctx, src)

	if len(ret) == 0 {
		panic("no return value specified for LoadRawPlugin")
	}

	var r0 *slo.Plugin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*slo.Plugin, error)); ok {
		return returnFunc(ctx, src)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *slo.Plugin); ok {
		r0 = returnFunc(ctx, src)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slo.Plugin)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, src)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// SLOPluginLoader_LoadRawPlugin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadRawPlugin'
type SLOPluginLoader_LoadRawPlugin_Call struct {
	*mock.Call
}

// LoadRawPlugin is a helper method to define mock.On call
//   - ctx context.Context
//   - src string
func (_e *SLOPluginLoader_Expecter) LoadRawPlugin(ctx interface{}, src interface{}) *SLOPluginLoader_LoadRawPlugin_Call {
	return &SLOPluginLoader_LoadRawPlugin_Call{Call: _e.mock.On("LoadRawPlugin", ctx, src)}
}

func (_c *SLOPluginLoader_LoadRawPlugin_Call) Run(run func(ctx context.Context, src string)) *SLOPluginLoader_LoadRawPlugin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *SLOPluginLoader_LoadRawPlugin_Call) Return(plugin *slo.Plugin, err error) *SLOPluginLoader_LoadRawPlugin_Call {
	_c.Call.Return(plugin, err)
	return _c
}

func (_c *SLOPluginLoader_LoadRawPlugin_Call) RunAndReturn(run func(ctx context.Context, src string) (*slo.Plugin, error)) *SLOPluginLoader_LoadRawPlugin_Call {
	_c.Call.Return(run)
	return _c
}
